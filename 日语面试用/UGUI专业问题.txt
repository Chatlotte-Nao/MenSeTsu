1、UGUI的合批规则
假设Canvas下有四个Image、分别为u1、u2、u3、u4。
Unity首先会判断这四个物体的深度值、如果当前为隐藏状态的话，深度值为-1，然后按照在Canvas下的顺序进行深度值判断，
如果有物体的Mesh覆盖在一个物体的Mesh上的话，那么该物体的深度值会比被覆盖物体大一，然后会检测Canvas下的顺序相邻的物体的MaterialId和TextureId是否相同，如果相同他们的深度值会设置为同一个值。最后得到一个待绘制合批的数组，如果深度值为-1的话不会被放进这个数组里，
按照深度值来进行一个Mesh一个Mesh的绘制，如果u1和u3的MaterialId和TextureId相同，但是u2与他们不相同的话，u2就会打断u1和u3的合批。

カンバスにはu1,u2,u3,u4四つのイメージがあると仮定します。Unityはこの四つのイメージの深度値を評価します、非表示の場合、深度値はー１となります、そしてカンバス内の順序(junjo[1])によって深度値を評価します。
もし一つのメッシュが別のメッシュを覆い隠して場合、その深度値は覆い隠されたの深度値より１大きい、
そしてカンバス内の隣接するイメージのマテリアルIDとテクスチャIDは同じかどうかを確認します、同じであれば深度値は同じ値に設定されます。最終的に、描画対象の配列が得られます、深度値はー１では、配列に含まれません。
深度値によって一つずつのメッシュを描画する。もしu1とu3のmatIDとTexIDが同じ場所、しかしu2は異なる場所、
u2はu1とu３のバッチングを妨げます。
2、如何减少UGUI产生的DrawCall
减少可能会引起脏标记的操作，也就是尽量减少UI元素变化。
使用相同的Material，使用图集使得TextureID相同。注意Canvas下的子物体排序顺序，不要被中间的物体打断相邻物体的合批。
不使用SetActive进行隐藏，而使用改变坐标进行隐藏。动静分离、ui元素容易变化的放在一个Canvas下，不变化的放在另一个Canvas下。
减少Mask的使用，只是矩形遮罩的话使用RectMask2D。

ダティーマークを引き起こすの可能性あるの操作を減らします、可能な限りにUI要素の変化(henka)を減少します。
同じマテリアルを使用し、スプライトアトラスを使用してテクスチャIDが同じになる。カンバス内のオブジェクトの並び順を注意し、中間のオブジェクトが隣接するオブジェクトのバッチングを妨げ(samatage)ないようにします。
非表示にする際は、SetActiveを使用せずに座標を変更します。静的な要素と変更しやすいUI要素は異なるCanvasに配置し
マスクの使用を減らす、矩形(kukei)のマスクにはRectMask2Dを使用します。

减少Layout相关组件的使用，因为layout组件计算布局的方式很耗费性能，
.不要嵌套Layout组件使用。

レイアウトコンポーネントの使用を減らし、レイアウトコンポーネントはレイアウトの計算が非常に性能を消耗(shoumou)するから、
レイアウトコンポーネントのネスト使用を避けます。

尽量一个界面的元素打进一个图集、尽量打小图进去、大图单独不打图集就行。

1つの画面の要素をできるだけ1つのスプライトアトラスに組み込みます。小さな画像を含めるようにし、大きな画像は単独でスプライトアトラスに含めないでください。

3、循环列表
UGUI中的循环列表是一种用于高效处理大量元素列表的方法。通常，当列表中的元素多到无法全部显示在视图区域内时，通过将滚动出屏幕的一些元素隐藏，并在需要时重新利用这些元素来优化内存和性能，从而实现高效的处理。

UGUIの循環リストは、大量の要素を持つリストを効率的に扱うための手法です。通常、表示領域に格納されないほど多くのアイテムがある場合、画面外にスクロールしていくつかのアイテムを非表示にしておき、必要に応じて表示領域内に再利用することで、メモリやパフォーマンスでの効率的に処理できます。




