【C#的List和Array有什么区别 】
C#のListとArrayの違いは何ですか
【List不会产生装箱拆箱】
Listはボックス化やボックス化解除を発生させません。
【什么是GC】
GC是一个自动内存管理系统。它负责自动回收不再使用的对象，以释放内存空间，防止内存泄漏。
GCは自動メモリ管理システムです。使用されなくなったオブジェクトを自動的に回収し、メモリ空間を解放してメモリリークを防ぐ役割を果たしています。
【如何减少GC】
GCを減らす方法
使用对象池、避免过度装箱拆箱、减少string拼接、定期手动清理资源、使用值类型，最根本目的是减少向堆空间申请内存的操作。
オブジェクトプールを使用し、過度なボックス化とボックス化解除を避け、stringの連結を減らし、定期的に手動でリソースをクリーンアップし、値型を使用します。その最も根本(konpon)的な目的は、ヒープスペースへのメモリ割り当て操作を減らすことです。
【GC的坏处】
GCの欠点
由于性能开销应用程序可能会被暂停、因为垃圾的收集是不确定的、在一些情况下进行GC可能会导致应用程序崩溃、频繁的申请内存回收可能产生内存碎片。
性能のコストによってアプリケーションの一時停止可能性があります、ガベージコレクションは不確定なため、特定の状況下(ka)ではGCの実行がアプリケーションのクラッシュを引き起こすことがあります。また、頻繁にメモリを回収すると、メモリの断片化が発生する可能性があります。
【GC原理】
GC（Garbage Collection）の原理
标记-对被使用的对象进行标记。
清除-被标记的对象不再被使用时，进行回收释放内存
マーク - 使用されているオブジェクトをマークする。
削除 - マークされたオブジェクトが使用されなくなったとき、メモリを解放するために回収を行います。
【什么时候会进行GC】
いつGCが行われますか。
内存压力：当系统内存不足时，垃圾回收器会启动垃圾回收以释放不再使用的对象的内存，从而缓解内存压力。
メモリプレッシャー：システムメモリが不足しているとき、ガベージコレクタは使用されなくなったオブジェクトのメモリを解放するためにガベージコレクションを開始し、メモリプレッシャーを軽減(keigen)します。
GC.Collect 方法： 开发者可以调用 System.GC.Collect 方法来显式触发垃圾回收。但一般情况下，不建议频繁手动调用垃圾回收，因为它可能影响性能，并且垃圾回收器通常能够很好地自动管理内存。
GC.Collect メソッド：開発者は System.GC.Collect メソッドを呼び出して明示的にガベージコレクションをトリガーすることができます。しかし、一般的には頻繁に手動でガベージコレクションを呼び出すことは推奨されません。なぜなら、それはパフォーマンスに影響を与える可能性があり、ガベージコレクタは通常、メモリを自動的に適切に管理できるからです。
对象被设置为 null： 如果开发者将对象的引用设置为 null，垃圾回收器可能在某个时刻回收这些对象。
オブジェクトが null に設定されると、ガベージコレクターはそのオブジェクトをある時点で回収する可能性があります。
【C#的闭包：】
C#のクロージャ
如果一个类里，有一个闭包捕获了一个引用变量，不把这个类手动释放的话，会长时间保存下去这个引用变量，需要手动把这个类置为null。
もしクラス内でクロージャが参照変数を捕捉(hosoku)している場合、そのクラスを手動で解放しない限り、その参照変数は長期間保持されます。この場合、クラスを明示的に null に設定する必要があります。

再把那边的添加过来一些



