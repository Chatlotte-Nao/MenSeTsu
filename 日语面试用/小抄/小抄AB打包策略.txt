ビルド、デプロイ   (构建、配置)
【1、为什么要使用AssetBundle？】
なぜAssetBundleを使用するのか
Unity中运行时加载资源的方式可以通过Resource目录下的文件加载和AssetBundle文件的加载。
Resource目录下的文件会被打进安装包里，无法做资源热更新，而且会导致安装包变大。而
AssetBundle不需要打进安装包里也能使用，并且能压缩，进行资源热更新。
Unityでは、ランタイム時にリソースを読み込む方法として、Resourceフォルダ内のファイルを読み込む方法とAssetBundleファイルを読み込む方法があります。Resourceフォルダ内のファイルはインストールパッケージに含まれ、リソースのホットアップデートができません、またインストールパッケージが大きくなってしまいます。一方、AssetBundleはインストールパッケージに含めなくても使用でき、圧縮も可能で、リソースのホットアップデートが行えます。
【2、AssetBundle三种压缩方式】
AssetBundleの3つの圧縮方式
None(nan):
完全不压缩资源。
リソースを完全に圧縮しない
LZMA:
压缩的资源最小，不过读取的时候解压速度最慢、而且解压出来的资源也最大。
圧縮されたリソースは最も小さいですが、読み込み時の解凍速度が最も遅く(osoku)、解凍されたリソースも最大になります。
LZ4:
压缩的资源比LZMA大，不过读取的时候解压速度很快，而且解压出来的资源也没有很大。
圧縮されたリソースはLZMAより大きいですが、読み込み時の解凍速度が速く、解凍されたリソースもそれほど大きくありません。
【3、AssetBundle的打包策略】
AssetBundleのビルド戦略
AB文件不能打的太大。
ABファイルは大きくしすぎてはいけません。
首先构建一份json文件、含有三种类型，分别为Ignore(必须忽略该文件夹)、Collect(必须收集该文件夹)、Passive(该文件夹被引用时收集)
Ignore是必须忽略该文件夹，对应文件夹的文件不会被打包成AssetBundle。
Collect是收集该文件夹下的文件打包成AssetBundle，通常是prefab之类。
Passive是该文件夹下的文件被Collect类型文件夹下的文件所引用时进行收集打成AssetBundle包
Collect和Passive会确定为，哪些文件夹下是按照文件后缀名单个文件打成一个AssetBundle，哪些文件夹下是整个文件夹下的文件打成一个AssetBundle。
然后确定好哪些类型的文件，要如何进行分配打包。比如启动器的资源和后续热更新资源区分开来、再对热更新资源部分进行整体细分。
まず、3種類のタイプを含むjsonファイルを作成します。それぞれは、Ignore（このフォルダを無視する必要がある）、Collect（このフォルダを収集する必要がある）、Passive（このフォルダが依存されたときに収集する）です。
Ignoreは、対応するフォルダのファイルがAssetBundleにパッケージ化されないことを意味します。
Collectは、そのフォルダ内のファイルを収集してAssetBundleにパッケージ化することを意味し、通常はプレハブなどです。
Passiveは、そのフォルダ内のファイルがCollectタイプのフォルダ内のファイルによって依存された場合に収集してAssetBundleにパッケージ化することを意味します。
CollectとPassiveは、どのフォルダ内のファイルがファイル拡張子(kakuchoushi)に従って単一のファイルとしてAssetBundleにパッケージ化されるか、またはどのフォルダ内のファイルが全体としてAssetBundleにパッケージ化されるかを決定します。
その後、どのタイプのファイルをどのように分配(bunpai)してパッケージ化するかを決定します。例えば、起動時のリソースと後続(kouzoku)のホットアップデートリソースを区別し、さらにホットアップデートリソース部分を細分(saibun)化します。
【4、如何避免AssetBunde文件的重复打包】
AssetBundleファイルの重複(choufuku)パッケージ化を避ける方法。
在对资源文件进行AssetBundle打包时，会查找该文件的依赖文件收集其GUID，将GUID存放进一个哈希表里。然后将自己设置好AB文件名存入一个哈希表里，这个哈希表以AB文件名作为Key值，然后遍历依赖路径时，使用GUID哈希表判断是否在这个哈希表中，然后再判断AB文件名是否已经在AB文件名哈希表里，使用两个哈希表防止重复打包。
リソースファイルをAssetBundleにパッケージ化する際に、そのファイルの依存ファイルを検索し、それらのGUIDを収集(shuushuu)してハッシュテーブルに保存します。そして、自分のABファイル名前を設定して別のハッシュテーブルに保存します。このハッシュテーブルはABファイル名前をキーとしています。次に、依存リソースパスを遍歴(henreki)する際に、GUIDハッシュテーブルを使用してそのGUIDがこのハッシュテーブルに存在するかを判断します。その後、ABファイル名前がすでにABファイル名前ハッシュテーブルに存在するかを確認します。これら二つのハッシュテーブルを使用することで重複パッケージ化を避けます。
【5、打完AB包创建清单文件用来热更新使用】
ABパッケージを作成した後、ホット更新に使用するためのマニフェストファイルを作成します。
利用构建AssetBundle得到的主AB包获取所有AssetBundle的信息。创建一份文件、文件上记录了当前资源版本号、所有AssetBundle的名字、文件路径、MD5、文件大小。这份文件主要用来资源更新使用。标记AssetBundle是否需要首包下载，标记这个AssetBundle属于哪个AssetBundle附带的资源跟随这个AssetBundle一起进行下载，热更新会先下载资源清单与本地清单进行比较再决定需不需要下载资源。
AssetBundleを構築して得られたメインABパッケージから、すべてのAssetBundleの情報を取得します。そして、現在のリソースバージョン、すべてのAssetBundleの名前、ファイルパス、MD5、ファイルサイズを記録したファイルを作成します。このファイルは主にリソース更新に使用されます。AssetBundleが初回ダウンロードに必要かどうかをマークし、このAssetBundleがどのAssetBundleに付随(fuzui)するリソースであるかをマークします。リソース更新時にはまずリソースリストをダウンロードし、ローカルリストと比較して、ダウンロードが必要かどうかを決定します。
//【6、如何实现文件需要时下载】
ファイルが必要な時にダウンロードする方法を実現するにはどうすればよいか
使用一份策略文件，里面记录下载一个资源时，需要附带下载哪些资源，就比如加载一个界面Prefab资源时，如果这个prefab还没有被下载的话，会请求下载，这个界面Prefab需要动态加载一些图片、这些图片就是附带资源，这个界面Prefab资源就是加载入口，加载这个界面Prefab的时检查有哪些附带资源，一起进行下载。在创建清单文件时，标记AssetBundle是否需要首包下载，这个也通过策略文件进行决定，然后记录是否已经下载了防止重复下载，如果MD5变化了的话再下载。
ポリシーファイルを使用して、あるリソースをダウンロードする際にどのリソースを一緒にダウンロードする必要があるかを記録します。例えば、あるインターフェースのPrefabリソースをロードする場合、そのPrefabがまだダウンロードされていなければ、ダウンロード要求を行います。このインターフェースのPrefabには、動的に読み込む画像などの付随リソースがあります。このインターフェースのPrefabリソースがロードエントリであり、このインターフェースPrefabをロードする際に、どの付随リソースがあるかを確認し、一緒にダウンロードします。

目録(mokuroku)ファイルを作成する際に、AssetBundleが初回パッケージダウンロードに必要かどうかをマークします。これもポリシーファイルを通じて決定され、ダウンロードされたかどうかを記録して重複ダウンロードを防ぎます。MD5が変更された場合に再度ダウンロードします。



