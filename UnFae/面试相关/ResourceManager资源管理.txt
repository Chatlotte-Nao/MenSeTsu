1、资源管理实现了什么？
首先实现一个AssetBundleLoader类、用来进行AssetBunde的加载和卸载，缓存已经加载出来的AssetBunde。
使用这个AssetBundle加载器进行AssetBundle加载时，会根据主AssetBundle包的Mainfest获取这个AssetBundle的所有依赖AssetBundle
,先将所有的依赖AssetBundle加载出来，并且每加载出一个AssetBundle，手动进行引用计数，标记这个AssetBundle的被引用次数加一。
随后自己的引用计数也要增加一。
然后卸载一个AssetBundle时，会将自身的引用计数减一，如果引用计数为0的话，就将这个AssetBundle卸载掉。
然后在循环遍历自己的依赖资源、进行上述操作的递归调用，进行依赖资源的引用计数修改及卸载。

然后再实现一个ResourceManager类、使用主mainfest提供各种API进行各种类型的资源加载、分别处理编辑器模式下和AssetBundle模式下的资源加载方式。
再提供卸载AssetBundle资源的API进行卸载资源。

2、什么时候进行资源卸载？
场景切换的时候，进行一次DisposeAll。释放未被使用的AssetBundle.进行一次GC。
同时会提供API供其他程序判断是否要单独立即释放掉某个AB资源。
在不需要某项资源时，手动进行资源卸载。比如关闭一个界面的时候，会手动进行资源卸载。



【短期时间内调用次数密集的重点关注】
无论是AssetBundle还是资源加载，都要关注加载的频率。
通常对于频繁加载的对象，我们可以通过建立缓存池的方法，先加载一次后将其加入缓存，后续就无须进行加载了。

【AssetBunde驻留优化】
资源的加载可以使用缓存池的方式来进行优化，AssetBundle的加载也是类似的。
对于同一个AssetBundle进行频繁的加载通常是不合理的（如下图所示），对于频繁加载卸载的AssetBundle，建议将其加入缓存，常驻于内存中。

【检查断点续传】
下载AB包之前，要检查该AB包是否下载中断过，例如用户杀程序，卡死等情况。
前文有讲解过，下载AB包会先下载到临时文件夹，全部下载成功后，全部剪切到persistentDataPath沙盒目录中。
回顾一下之前的筛选机制，哪些AB包可以加入下载列表，其中并没有临时下载目录的判断。
该AB包数据是否加入列表要经过下面几个筛选
判断persistentDataPath沙盒目录是否存在该AB包，如果存在证明之前下载过，无需加入下载列表。
判断StreamingAsset目录中是否存在该AB包，如果存在证明打包时该AB包已经在包体里，无需加入下载列表。
如果该AB包的下载类型是游戏内下载，或者叫边玩边下，那么不需要在游戏启动热更时下载，无需加入下载列表

检查该AB包是否在临时文件夹中存在，如果不存在则跳过
如果已存在，创建该临时下载文件的MD5，与下载清单中的MD5做对比
如果MD5对比一致，则标记该AB包数据为SkipDownload，同时标记下载数据长度，供UI显示
