知道怎么做？
知道为什么这么做？
知道为什么不那么做？
将节奏由自己掌控。
种一棵树最好的时间是十年前，其次是现在。

Application.streamingAssetPath
在安卓上为jar:file://+Application.dataPath+"/!assets"
在IOS上位file://+Application.dataPath+"/Raw"

设置com.XXX.XXXX安卓平台身份确认名
PlayerSettings.SetApplicationIdentifier(BuildTargetGroup.Android,"");

C#的List和Array有什么区别 List不会产生装箱拆箱
Lua面向对象
Lua闭包原理--词法作用域
如何减少GC--对象池、避免过度装箱拆箱、减少string拼接、定期手动清理资源、使用值类型，根本是减少向堆空间申请内存的操作。
GC的坏处--性能开销应用程序可能会被暂停、垃圾的收集是不确定的在意外的情况下进行GC导致应用程序崩溃、频繁的申请内存回收、可能产生内存碎片
【GC原理-- 标记--垃圾收集器从根对象开始，递归地遍历所有可达的对象，并对它们进行标记。根对象通常是全局变量、栈上的对象引用、静态字段等。
清除--垃圾收集器遍历堆中的所有对象，清除没有标记的对象，将其内存回收。这些对象被认为是不再可达的垃圾。
分代回收，0、1、2，倾向于回收新生代对象，活得久了就会进入老年代。
】
什么时候会进行GC
Generation 触发： .NET 的垃圾回收器使用分代垃圾回收策略。对象在堆上分为 0 代、1 代和 2 代，垃圾回收的频率取决于对象所在的代。
通常情况下，垃圾回收器会更频繁地回收 0 代，较少地回收 1 代和 2 代。

内存压力： 当系统内存不足时，垃圾回收器会启动垃圾回收以释放不再使用的对象的内存，从而缓解内存压力。

GC.Collect 方法： 开发者可以调用 System.GC.Collect 方法来显式触发垃圾回收。但一般情况下，不建议频繁手动调用垃圾回收，
因为它可能影响性能，并且垃圾回收器通常能够很好地自动管理内存。

对象被显式设置为 null： 如果开发者将对象的引用设置为 null，使得对象变为不再可达，垃圾回收器可能在某个时刻回收这些对象。
空闲时： 当系统空闲时，垃圾回收器可能会运行，以最小化对应用程序的影响。

C#的闭包：
闭包补货的是变量的引用，而不是值得拷贝
如果一个类里，有一个闭包捕获了一个引用变量，不把这个类手动释放的话，会长时间保存下去这个引用变量，需要手动把这个类置为null

gc后引用数据的地址会不会改变？如何保持不变
在C#中，无论是强引用类型还是其他引用类型，在垃圾收集（GC）过程中都可能发生内存地址的变化。GC的主要任务之一是整理内存空间，减少内存碎片，这通常通过移动对象来实现。因此，即使是强引用类型，其内存地址也可能会在GC后变化。
使用fixed关键字固定住。

unity如何调用它的生命周期？
在cpp层实现了个类似C# 反射的机制，其实就是直接去找Start、update的函数指针。如果这个monobehaviour有实现start，那么就调
，没那么就不调。monobehaviour自身就干干净净的不包含这些函数的定义。让用户自己按需声明。

装箱拆箱有什么性能差异
如果Dral Call有60个，那么一帧就要渲染60次图形
DrawCall详细解释--一个 Draw Call 表示图形引擎发送渲染一个物体或一组物体的命令到 GPU 进行绘制的操作、压力在CPU准备数据模型定点、法线数据(渲染到图形上相关数据)、准备数据完后再通知GPU渲染、
怎么避免重复加载AB包--引用计数、字典缓存
AB包的unload()false和true的区别，如果一个prefab用了AB包1的资源，然后这个AB包1被unload(false)了，又重新加载这个AB包1，又使用了同一个资源，那这两个资源有区别吗？
layout原理，为什么开销这么大
说一下AB策略、打包策略
UI渲染流程--ui元素构建、ui元素更新更新位置、大小颜色，update中完成、合批、裁剪剔除、顶点和像素着色器计算确定如何绘制UI元素、画布渲染告诉GPU这些信息来进行渲染
ui物体要避免使用setactive来控制显隐、带动画的物体也是
UGUI中透明物体渲染、避免，防止重绘浪费
C# lambday和匿名委托
UGUI合批是怎么进行合批，递归遍历？
做过最复杂的UI界面、名片勋章
UI框架、有没有MVC
新手引导、消耗材料那边掉线了怎么办
多看一下HuaTuo框架
【使得IL2CPP由纯AOT、变为了AOT+解释器部分、实现底层原生支持动态加载assembly，而非Lua的虚拟机、实现了一个高效的元数据(dll)解析库
改造了元数据管理模块，实现了元数据的动态注册
实现了一个IL指令集到自定义的寄存器指令集的compiler
实现了一个高效的寄存器解释器、
HybridCLR是原生的c#热更新方案。通俗地说，il2cpp相当于mono的aot模块，HybridCLR相当于mono的interpreter模块，两者合一成为完整mono。HybridCLR使得il2cpp变成一个全功能的runtime，
原生（即通过System.Reflection.Assembly.Load）支持动态加载dll，从而支持ios平台的热更新。

正因为HybridCLR是原生runtime级别实现，热更新部分的类型与主工程AOT部分类型是完全等价并且无缝统一的。可以随意调用、继承、反射、多线程，不需要生成代码或者写适配器。

其他热更新方案则是独立vm，与il2cpp的关系本质上相当于mono中嵌入lua的关系。因此类型系统不统一，为了让热更新类型能够继承AOT部分类型，需要写适配器，并且解释器中的类型不能为主工程的类型系统所识别。特性不完整、开发麻烦、运行效率低下。
】

Canvas网格重建分为Rebatch和Rebuild。
ReBatch：合批绘制成一张网格。
Rebuild：layout组件的rebuild消耗，graphic组件的rebuild消耗，特别是在显隐时会设置脏标记引发rebuild。
不应该因为动的组件改了而影响到根本不改变的组件
UI射线检测相关逻辑代码在GraphicRayCaster里

Unity相机近小远大实现原理？
在Unity中，透视相机（Perspective Camera）通过模拟人眼的视角来实现近小远大的效果，这种效果的原理基于透视投影的几何特性。以下是透视相机实现近小远大的主要原理：
1. 视锥体（View Frustum）
透视相机在渲染3D场景时，会根据相机的位置和朝向创建一个视锥体。视锥体的顶点在相机的位置，底部则是视锥体的远剪裁面（far clipping plane）。视锥体的形状决定了在3D空间中哪些物体会被渲染。
2. 透视投影矩阵（Perspective Projection Matrix）
Unity通过透视投影矩阵将3D空间中的物体转换为屏幕空间。这种矩阵变换会将物体的世界坐标按其深度（即距离相机的距离）进行缩放，导致离相机越远的物体在屏幕上看起来越小，而离相机越近的物体看起来越大。



四个点，如何判断一个点是否在三个点组成的平面上。叉乘

3D模型物体，结合UI界面开发。

C#中各个的意义？比如接口的意义

总结平时工作流程、
总结本地化工作流程。


战斗相关的多看一下
UGUI源码研究一下
China：
我能否循序渐进做点有挑战的工作。

双休吗，平时几点下班。
问加班到几点能算调休时间或者加班费。
问一下年假，周末是否双休
问做这个项目的有多少人、多少个客户端
问项目稳定性、开发了多久
问公司网络能不能直接翻墙
问如何提高自己，学习的？





Japan：
来日理由：
1、特别喜欢日本的动漫、游戏、音乐、风景、文化等。想体验能够随意逛漫画书店买漫画、电玩店买PS光盘的生活。
2、国内35岁后不好找工作，近两份工作又都是被裁员的，综合考虑想来日本换个工作环境。
3、想体验新的人生，学习新的语言，接触新的文化。





