1、冒泡排序
隣接する要素の大小を比較する、最大値または最小値要素を一番右に移動させます。
2、快速排序
配列から基準となる数(kazu)を選択し。
そして、配列を基準より小さい数と基準より大きい数の二つの配列に分割します。
その後、左の配列と右の配列に対してそれぞれ同じ操作を繰り返します。
これを再帰的に行い、分割できる配列がなくなるまで続けます
3、归并排序
配列を中央の要素から左右に等しいサイズのサブ配列を分割し、その後、左右のサブ配列に
対して再帰的に分割を繰り返す、最後に左右のサブ配列を結合して一つの配列にします。
4、BFS
始点をキューに追加し、その頂点を訪れた(otozure)こととマークします。
キューから頂点を取り出し、その隣接頂点をキューに追加し、まだ訪れていない頂点は訪れたこととマークします。キューが空になるまでこのプロセスを繰り返します。
5、DFS
始点をスタックに追加し、その頂点を訪れたこととマークします、
スタックから頂点を取り出し、その隣接頂点をスタックに追加し、まだ訪れていない頂点を訪れたこととマークします。スタックが空になるまでこのプロセスを繰り返します。
6、DP
問題を分割し、過去を覚え、重複計算を減らします。
典型的な特徴には、最適な部分を構造、状態遷移方程式、境界、
重複する部分問題があります。
7、ダイクストラ法
始点から終点への最短経路を見つけるために、まずSとUという二つの配列が必要です。Sの役割は、
最短経路が既に求められた頂点を記録することであり、Uはまだ最短経路が求められていない頂点を記録します。
初期状態では、配列Sには始点Dしか含まれず、配列Uには始点D以外のすべての頂点を含まれ、配列Uには
各頂点から始点Dまでの距離が記録されています。頂点が始点D隣接していない場合、距離は無限大です。
その後、配列Uから最も短い経路の頂点K見つけ、それを配列Sに追加し、同時に配列Uから削除します。その後、
配列U内の各頂点から始点Dまでの距離を更新します。これらの操作を繰り返し、すべての頂点を探索するまで続けます。