1、UGUI的合批规则
カンバスにはu1,u2,u3,u4四つのイメージがあると仮定します。Unityはこの四つのイメージの深度値を評価します、非表示の場合、深度値はー１となります、そしてカンバス内の順序(junjo[1])によって深度値を評価します。
もし一つのメッシュが別のメッシュを覆い隠して場合、その深度値は覆い隠されたの深度値より１大きい、
そしてカンバス内の隣接するイメージのマテリアルIDとテクスチャIDは同じかどうかを確認します、同じであれば深度値は同じ値に設定されます。最終的に、描画対象の配列が得られます、深度値はー１では、配列に含まれません。
深度値によって一つずつのメッシュを描画する。もしu1とu3のmatIDとTexIDが同じ場所、しかしu2は異なる場所、
u2はu1とu３のバッチングを妨げます。
2、如何减少UGUI产生的DrawCall
ダティーマークを引き起こすの可能性あるの操作を減らします、可能な限りにUI要素の変化(henka)を減少します。
同じマテリアルを使用し、スプライトアトラスを使用してテクスチャIDが同じになる。カンバス内のオブジェクトの並び順を注意し、中間のオブジェクトが隣接するオブジェクトのバッチングを妨げ(samatage)ないようにします。
非表示にする際は、SetActiveを使用せずに座標を変更します。静的な要素と変更しやすいUI要素は異なるCanvasに配置し
マスクの使用を減らす、矩形(kukei)のマスクにはRectMask2Dを使用します。

レイアウトコンポーネントの使用を減らし、レイアウトコンポーネントはレイアウトの計算が非常に性能を消耗(shoumou)するから、
レイアウトコンポーネントのネスト使用を避けます。

1つの画面の要素をできるだけ1つのスプライトアトラスに組み込みます。小さな画像を含めるようにし、大きな画像は単独でスプライトアトラスに含めないでください。

3、循环列表
UGUIの循環リストは、大量の要素を持つリストを効率的に扱うための手法です。通常、表示領域に格納されないほど多くのアイテムがある場合、画面外にスクロールしていくつかのアイテムを非表示にしておき、必要に応じて表示領域内に再利用することで、メモリやパフォーマンスでの効率的に処理できます。




