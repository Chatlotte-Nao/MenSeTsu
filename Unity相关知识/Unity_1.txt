1. Unity のライフサイクルについて説明してください。

回答例：

MonoBehaviour（モノビヘイビア） には Awake（アウェイク）, Start（スタート）, Update（アップデート）, LateUpdate（レイトアップデート）, OnDestroy（オンドストロイ） などのライフサイクルメソッドがあります。
Awake（アウェイク） はスクリプトが読み込まれた時、Start（スタート） は有効化された最初のフレームで呼ばれます。
Update（アップデート） は毎フレーム実行され、LateUpdate（レイトアップデート） は全ての Update の後に実行されます。

2. Prefab（プレハブ） を使うメリットは何ですか？

回答例：

Prefab（プレハブ）はオブジェクトのテンプレートとして再利用でき、シーン全体で一貫性を保ってます。
また、更新すると全てのインスタンスに反映されるので、開発効率や保守性が向上します。

3. GC（ジーシー、ガベージコレクション） 発生を減らす方法は？

回答例：

ループ内での new（ニュー）、文字列連結、Boxing（ボクシング） を避けます。
また、List（リスト）.Clear（クリア） を使って再利用し、不要なオブジェクトは Object Pool（オブジェクトプール） で管理します。
Unity（ユニティ）のリアルタイム性を維持するために、GC 発生を最小限に抑えることが重要です。

4. Update（アップデート） を最適化する方法は？

回答例：

可能な限り Update（アップデート） 内での処理を減らし、イベントや Coroutine（コルーチン） で代替します。
また、複数のオブジェクトが同じ処理をする場合はマネージャーを作り、一括で制御します。

5. Addressables（アドレッサブルズ） を使う利点は？

回答例：

Addressables（アドレッサブルズ）を使うと、リソースを必要な時に動的にロードでき、メモリ効率が良くなります。
また、リモート配信にも対応しており、大規模なプロジェクトで特に有効です。

6. UI 最適化のポイントは？

回答例：

Canvas（キャンバス） の数を減らし、不要な再描画を避けます。
また、アンカーとピボットを活用して解像度に応じたレイアウトを実現し、TextMeshPro（テキストメッシュプロ） を使って描画品質とパフォーマンスを両立します。

7. Coroutine（コルーチン） と async（アシンク） / await（アウェイト） の違いは？

回答例：

Coroutine（コルーチン）は Unity 独自の仕組みで、yield（イールド） return によって処理をフレーム単位で分割できます。
一方 async（アシンク）/ await（アウェイト）は C# の非同期処理で、I/O バウンドの処理に適しています。
Unity では用途に応じて使い分けます。

8. Rigidbody（リジッドボディ） と Collider（コライダー） の違いは？

回答例：

Collider（コライダー）は当たり判定を提供し、Rigidbody（リジッドボディ）は物理演算を有効にします。
Rigidbody を付けないと物理挙動は発生せず、Collider のみでトリガーや静的オブジェクトを表現できます。