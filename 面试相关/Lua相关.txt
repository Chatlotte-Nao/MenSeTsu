1、Lua如何实现面向对象。
实现一个new方法，方法内部先声明一个空表obj
然后使用setmetatable(obj,self)，把self设置为obj的元表。
再使用self._index=self。

2、Lua的闭包
Lua的闭包（Closure）是指一个函数和该函数创建时的环境（包括函数内使用到的外部变量）组合而成的对象。闭包允许函数捕捉和携带其创建时的局部变量，这些变量在函数调用时依然可以访问和使用。

词法域是指一个函数可以嵌套在另一个函数中，内部的函数可以访问外部函数的变量。
闭包的实现原理
当Lua编译一个函数时，它会生成一个原型（prototype），原型中包括函数的虚拟机指令、函数中的常量（数值和字符串等）和一些调试信息。在任何时候只要Lua执行一个function .. end表达时，它都会创建一个新的闭包（closure）。每个闭包都有一个相应函数原型的引用以及一个数组，数组中每个元素都是一个对upvalue的引用，可以通过该数组来访问外部的局部变量。

3、Lua优化。
尽量使用局部变量而非全局变量。
table表如果能直接填充元素，就填充，而非动态扩容，
非常长的字符串连接时，使用table.concat，而非使用..连接。 

优化总结：

在写 Lua 代码时，你应该尽量使用 local 变量。比如，使用 local 变量 sin 来保存 math.sin

当需要创建非常多的小 size 的表时，应预先填充好表的大小，以避免 rehash。

在字符串连接中，我们应避免使用..。应用 table 来模拟 buffer，然后 concat 得到最终字符串。

在循环中，我们更需要注意实例的创建。我们应该把在循环中不变的东西放到循环外来创建

在存储数据到table中时，尽量使用数组的数据结构，可以减少内存占用。

如果无法避免创建新对象，我们需要考虑重用旧对象。

将性能瓶颈部分用 C/C++来写。

4、Lua C# 交互原理

C# Call Lua交互原理
C#先将数据放入栈中，然后Lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#

Lua Call C#交互原理
C#源文件生成Wrap文件、或C#源文件生成C模块，将Wrap文件和C模块注册到Lua的解析器中，最后再由Lua去调用这个模块的函数

面试问题：
Lua table表实现原理，为什么既能当数组，又能当字典？

Lua的table是由两个部分组成的：
数组部分：用于存储连续的整数键（如1, 2, 3, ...）的值。
哈希表部分：用于存储非整数键（如字符串、其他表、混乱的整数键）及其对应的值。
这种结构的设计使得Lua的table能够高效地处理常见的数组和字典操作。


