1、优化思想
性能优化首先要分析问题，定位问题，收集数据来证明问题，然后制定解决对策进行优化，不能简单地通过猜测，推断来做性能优化。
先优化IOS、再优化安卓，先共性性能优化，再进行兼容性方面的性能优化。

2、常用方法
隔离法：隔离可疑区域，逐步缩小问题范围。

对比法：观察相同情况下的前后差异。

3、借助性能分析工具，分析性能瓶颈点。

4、卡顿优化

降帧法：通过强制降低更新频率，减缓卡顿的时间。

摊帧法：在同一帧处理的逻辑分为若干份，分摊到若干帧去处理，从而缓解同一帧的处理时间，减缓卡顿现象。

限制数量法：当场景内创建某种物体（角色，特效等）的数量到底最大值时，便强制不再创建。

对象池：重用对象，取代单独地分配和释放对象。

IO优化：
因IO慢引起主线程等待，从而导致游戏卡顿的现象非常普遍，下面有一些常用的优化技法。

预加载：
将耗时的IO提前到某个时刻（游戏启动时，场景加载时，进入主界面时等）加载，比如有些角色资源大，可以在加载战斗场景时提前加载，以免战斗过程中卡顿。

异步加载：
将IO异步化，以避免卡主线程。此技法应用非常普遍了，不再累述。

压缩资源：
将本来零散的文件压缩成单个文件，或者对大文件利用一定算法（如哈夫曼编码）压缩，减少文件大小。这样也可以降低IO时间。当然，压缩资源也有副作用，需占用多一份内存，解压缩过程也要耗费额外的CPU。

多级缓存：

CPU有L1、L2、L3缓存，它们速度有差别；内存的存取速度远低于CPU缓存；硬盘存取速度又远低于内存；而网络更慢。

因而加载资源时，先尝试从内存缓存读取，再尝试从硬盘加载，最后再考虑从网络下载。


我们都知道CPU的频率是最高的，目前家用PC的主频可达3.2GHz甚至更高，CPU内有L1L3缓存，它们速度略有差别；内存的存取速度远低于CPU，一般是23GHz，约是CPU的1/10。硬盘存取速度又远低于内存，普遍是0.1Gb/s，远低于内存读取速度。而网络更慢，目前即便是光纤，也不过0.02Gb/s。通常我们能操控的是内存/磁盘和网络的数据，所以只要关注它们的速度，它们的速度关系大致如下图。

进度条：
将卡顿逻辑抽离出来，分成若干阶段（step），每完成一个step，给一帧时间刷新UI进度条。

5、UI优化：
图片纹理优化，选用合适的图片纹理压缩格式。
UI合批优化
使用图集
尽量防止网格重建和布局重建。
6、内存优化：
缓存法：将需要重复创建的对象缓存起来，销毁时将它放入缓存列表，再次创建时优先从缓存列表中读取。
缓存法可以降低内存的创建/删除频率，避免碎片化。常用于数量多且创建频繁的物体
控制GC：
GC的触发一般分为两种：
引擎触发。一般是时间间隔到了，或者内存占有量到了某个阈值，引擎便会触发GC。
用户调用。通常引擎也提供了API给游戏应用，以便逻辑层可以控制GC的时机。例如Unity的GC.Collect()接口可以触发GC操作。

但是触发GC需要遍历内存池/托管堆/各类缓存表，还可能引发内存碎片整理操作，所以它需要耗费一定的CPU性能，是引起掉帧和卡顿的罪魁祸首之一。那么，我们就需要在逻辑层采用一些方法，避免触发GC，或者减少触发GC的处理时间。常用的方法：
避免频繁创建/删除。这个好理解，频繁创建删除对象，会引起很多内存碎片和无用对象，增加触发GC的几率和时间。
帧更新内尽量避免临时对象和创建内存。
for/while等循环内避免避免临时对象和创建内存。
尽量避免申请大块内存。申请大块内存会导致内存暴涨，提升GC的几率。
避免内存泄漏。这个需要每个技术人员的职业技能和觉悟，也可以通过一些辅助工具检查内存泄漏，详见1.3。
主动调用GC。比如在进入战斗前后，切换场景前后，切换主要界面前后调用GC，可以一定程度上减少内存占用，避免掉帧/卡顿。

7、渲染优化：
合批
光照模型
遮挡剔除
贴图阴影
带宽优化。



