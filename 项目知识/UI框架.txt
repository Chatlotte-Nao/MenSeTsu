【UI框架优点】
1、不继承MonoBehaviour但和继承MonoBehaviour使用起来无任何差别。
2、不受MonoBehaviour生命周期影响，生命周期完全可控，代码运行顺序由自己控制。
3、智能化全自动化UI框架，无需手动创建脚本、声明方法、变量。UI脚本、方法、属性字段自动生成，UI组件自动拖拽绑定。

一个好的UI框架具备的不仅仅是代码层的简洁与低耦合，更重要的是重视UI的性能、效率、自动化。
性能点：
1、避免频繁的网格重建带来的大量性能消耗和垃圾回收。
2、避免调用SetActive带来的性能消耗和GC垃圾。
3、避免频发实例化造成的卡顿和性能消耗以及GC垃圾。
4、避免不必要的组件属性带来的性能开销。
5、避免不正确的组件顺序导致打断合批带来的性能开销。


1、UI管理系统(管理UI界面的生成、销毁、交互、以及生命周期)
WindowBehaviour类：与MonoBehaviour类似是所有界面都必须继承的最基础最顶层的类
主要负责UI界面的生命周期以及基础属性的声明。
WindowBase类：继承WindowBehaviour，是UI界面基类，负责部分共用功能的统一化处理，例如弹出、关闭动画、以及解耦合方法的声明等其他公用接口的处理。
UIManager类：管理所有UI界面的创建、隐藏、销毁以及生命周期的初始化等。
2、堆栈系统(管理UI有序弹出、比如刚进大厅会按照优先级反复弹出多个界面)
实现了一个先进先出的UI界面显示队列，每次只显示一个UI界面，当前UI界面关闭后自动弹出下一个。
主要利用队列的先进先出特性来实现，适合任务奖励连续弹出等操作。


3、灵活的层级系统(管理UI层级保证界面-特效-界面中间不会有穿插的现象)
将UI界面挂载的Canvas组件的RenderMode设置为Camera模式，这时能够设置Canvas的SortingOrder
值和Order in Layer值，SortingOrder值大的界面会遮挡住小的界面，而同一个SortingOrder值下，Order in Layer值大的界面则会
遮挡住小的界面，利用这个特点，每打开一个新界面时，Order in Layer值会自动递增，保证
新打开的界面覆盖在旧界面上，特效覆盖在界面上，如果有系统提示警告弹窗方面的界面那么它的SortingOrder值会比普通UI界面的值大，保证
覆盖在最上方。

4、自动化系统(管理UI繁琐且重复的工作让其自动化生成脚本、方法属性声明、组件绑定等)
为了简化创建UI界面时，重复编写代码，获取UI组件的工作，而编写编辑器工具脚本。
能够一键生成UI界面脚本，自动声明组件字段，自动拖拽对应组件绑定至对应的字段。
自动生成生命周期函数，自动生成UI事件代码，在原有的代码上自动生成新增的组件事件代码，不会覆盖原有代码。

开发者只需要搭架UI界面即可，后续所有的字段声明，组件绑定，对应组件事件方法的声明，自动化工具会做好，开发者只需要编写
一些逻辑相关的代码即可。极大地减少了开发时间。

具体如何实现的呢？
事先编写好代码脚本的模板字符串，使用编辑器工具生成UI界面脚本时，生成对应的代码，其中要获得UI控件(Button、Image之类)的时候，
需要提前在预制体中命名加上前缀类型名比如Button_Close这样，就会自动获取到Button_Close这个按钮的Button组件，然后会生成一份界面同名的DataComponent类，
用来获取对应组件并且会自动地添加到对应界面预制体上。

5、高性能系统(管理并解决UI元素与界面的性能问题，在框架底层彻底解决，避免后期的二次性能优化)
最大的程度去降低UI在游戏中所消耗的性能问题，主要实现以下几个功能。

1.一键优化合批。自动根据图集图片和相邻组件的特征进行重新排序。​

2.避免使用SetActive引起的UI重绘和GC垃圾。用CanvasGroup和Scale进行代替。​

3.使用UI对象池。避免频繁的克隆物体导致的卡顿和GC。​

4.智能化禁用不必要的组件属性。从而来避免一些不必要的性能开销。​

5.界面预加载。针对复杂一些的界面我们可以使用预加载进行提前加载物体，来确保在真正使用界面时，能够流畅度加载出界面。​

6.高性能文字描边。Unity描边组件是拷贝4份相同的文本顶点数占用量巨大。一个字母的Text加上Untiy的描边一共占用30个顶点。而我们的Text同样是一个字母加上描边能做到只占用6个顶点。性能是Unity组件的5倍。​

7.组件自动序列化。避免掉使用Find接口查找组件带来的性能消耗，而使用自动化序列化的方式拿到组件，将性能消耗尽可能的降至最低。