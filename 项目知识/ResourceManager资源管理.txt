1、资源管理实现了什么？
首先创建一个AssetBundleLoader类、用来进行AssetBunde的加载和卸载，缓存已经加载出来的AssetBunde。
使用这个AssetBundleLoader类进行AssetBundle加载时，会根据主AssetBundle包的Mainfest获取这个AssetBundle的所有依赖AssetBundle
,先将所有的依赖AssetBundle加载出来，并且每加载出一个AssetBundle，手动进行引用计数，标记这个AssetBundle的被引用次数加一。
随后自己的引用计数也要增加一。
然后卸载一个AssetBundle时，会将自身的引用计数减一，如果引用计数为0的话，就将这个AssetBundle卸载掉。
然后在循环遍历自己的依赖资源、进行上述操作的递归调用，进行依赖资源的引用计数修改及卸载。

然后再实现一个ResourceManager类、使用主mainfest提供各种API进行各种类型的资源加载、分别处理编辑器模式下和AssetBundle模式下的资源加载方式。
再提供卸载AssetBundle资源的API进行卸载资源。

【1. リソース管理の実装内容】
まず、AssetBundleLoader クラスを作成し、AssetBundle のロード・アンロードおよびキャッシュ管理を担当させます。
このクラスはロード済みの AssetBundle をキャッシュし、同一リソースの再読み込みを防止します。

AssetBundleLoader を用いて AssetBundle をロードする際は、メイン AssetBundle の Manifest から依存関係を取得し、
すべての依存 AssetBundle を先にロードします。
各 AssetBundle をロードするたびに、手動で参照カウント（Reference Count）を管理し、
依存 AssetBundle の参照回数を 1 増加させます。
同様に、自身の参照カウントも 1 増加させます。

アンロード処理では、対象の AssetBundle の参照カウントを 1 減少させ、
参照カウントが 0 になった場合に、その AssetBundle をアンロードします。
その後、依存している他の AssetBundle に対しても再帰的に同様の処理を行い、
参照関係を解消しながら不要なリソースを解放します。

次に、ResourceManager クラスを実装し、メイン Manifest を利用して
各種リソースをロードするための API を提供します。
このクラスでは、エディターモードとAssetBundle モードの両方に対応し、
それぞれの環境に適したロード処理を行います。
また、AssetBundle のアンロードを行うための API も提供し、
必要に応じて明示的にリソースを解放できるようにします。



2、什么时候进行资源卸载？
场景切换的时候，释放未被使用的AssetBundle.进行一次GC。
同时会提供API供其他程序判断是否要单独立即释放掉某个AB资源。
在不需要某项资源时，手动进行资源卸载。比如关闭一个界面的时候，会手动进行资源卸载。

【2. リソースをアンロードするタイミング】

シーン切り替え時
　使用されていない AssetBundle を解放し、Garbage Collection（GC）を実行します。

明示的なリリース
　他のシステムや UI から任意のタイミングで AssetBundle を解放できるように、
　専用の API を提供します。

不要リソースの手動解放
　特定のリソースが不要になった場合（例：UI 画面を閉じる際など）、
　手動でアンロード処理を実行し、メモリ使用量を抑制します。


无论是AssetBundle还是资源加载，都要关注加载的频率。
通常对于频繁加载的对象，我们可以通过建立缓存池的方法，先加载一次后将其加入缓存，后续就无须进行加载了。
资源的加载可以使用缓存池的方式来进行优化，AssetBundle的加载也是类似的。
对于同一个AssetBundle进行频繁的加载通常是不合理的（如下图所示），对于频繁加载卸载的AssetBundle，建议将其加入缓存，常驻于内存中。


【3. ロード頻度とキャッシュ戦略】

AssetBundle およびリソースのロード処理においては、ロード頻度に注意を払う必要があります。
頻繁にロードされるオブジェクトに対しては、**キャッシュプール（オブジェクトプール）**を利用することで最適化が可能です。
一度ロードしたリソースをキャッシュとして保持し、再利用することで、
同一リソースの再ロードを防ぎ、パフォーマンスを向上させます。

リソースのロード最適化にはキャッシュプールを用いる手法が有効であり、
これは AssetBundle のロード処理にも同様に適用できます。

同一の AssetBundle を繰り返しロード・アンロードするのは非効率的であり、
特に頻繁に利用される AssetBundle については、**キャッシュとして常駐（メモリ保持）**させることが推奨されます。

このようにすることで、無駄な I/O 処理を削減し、ロード時間およびメモリ断片化を抑えることができます。


【断点续传】
下载AB包之前，要检查该AB包是否下载中断过。
下载AB包会先下载到临时文件夹，全部下载成功后，全部剪切到persistentDataPath目录中。

AB包是否下载要经过下面几个筛选
判断persistentDataPath沙盒目录是否存在该AB包，如果存在证明之前下载过，无需加入下载列表。
判断StreamingAsset目录中是否存在该AB包，如果存在证明打包时该AB包已经在包体里，无需加入下载列表。

检查该AB包是否在临时文件夹中存在，如果不存在则跳过
如果已存在，创建该临时下载文件的MD5，与服务器端给的下载清单文件中记录的MD5值做对比
如果MD5对比一致，则标记该AB包数据为已下载，否则就要重新下载该AB包。

【4. ダウンロードの再開（断点続行）】

AssetBundle のダウンロード処理において、途中で中断された場合でも再開できるように、断点続行機能を実装します。
ダウンロードを開始する前に、対象の AssetBundle が途中までダウンロードされているかどうかを確認します。

■ ダウンロード手順

一時フォルダへの保存
AssetBundle はまず一時フォルダにダウンロードされます。
全てのファイルが正常にダウンロード完了した後、パーシステントデータパスディレクトリに移動（リネーム）されます。

ダウンロード判定フロー
ダウンロード対象かどうかは以下の手順で判定します：

パーシステントデータパス に同名の AssetBundle が存在する場合：
→ すでにダウンロード済みと判断し、ダウンロードリストに追加しません。

ストリーミングアセット フォルダに該当 AssetBundle が存在する場合：
→ アプリパッケージに同梱されているため、ダウンロード不要とします。

一時フォルダ内に該当 AssetBundle が存在する場合：
→ MD5 チェックを行います。サーバー側のリソースマニフェストに記載された MD5 値と比較し、一致すれば「ダウンロード済み」とみなし、
不一致の場合は再ダウンロードを実行します。

このフローにより、中断されたダウンロードを安全かつ効率的に再開でき、
無駄な通信やファイル破損を防ぐことが可能となります。
