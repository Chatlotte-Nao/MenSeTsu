1、Pivot（ピボット）
UI 要素自身の 基準点（原点）。
RectTransform の位置・回転・拡大縮小は、このピボットを中心に行われる。
例：Pivot を (0,0) にすると左下が基準点、(0.5,0.5) にすると中央が基準点になる。

2、Anchor（アンカー）
UI 要素が 親要素（親の RectTransform）に対してどう配置・伸縮するか を決める基準。
単一の点としても、範囲（最小・最大）としても設定できる。
画面解像度が変わった時に、自動で位置やサイズを調整することができる。

「Pivot は UI 要素自身の基準点、Anchor は親要素に対する相対基準です。
例えば、Anchor を画面の端に設定すれば、解像度が変わってもその位置を維持できます。」

3、異なる解像度に対応するために、UI をどのように設計しましたか？
「Anchor を活用して、画面端に追従するように設定しました。また、CanvasScaler でスケーリング方法を指定し、解像度が違ってもレイアウトが崩れないようにしました。」

4、ボタンやイベント処理はどのように実装しますか？
「Button コンポーネントにイベントを設定したり、EventTrigger を使ってクリックやドラッグを処理しました。C# スクリプトでコールバックを登録する方法もよく使います。」
　
5、UGUI を使った時にパフォーマンス上の問題に直面したことはありますか？どう解決しましたか？
「UI 要素が多すぎると DrawCall が増えて重くなる問題がありました。そのため、同じスプライトをアトラス化したり、不要な Canvas をまとめることで最適化しました。」

7、Draw Call を減らすためにどんな工夫をしましたか？
「スプライトをアトラス化してバッチ処理を効かせたり、Canvas を分けすぎないように工夫しました。また、動的に変化しない UI は別 Canvas にまとめて更新頻度を減らしました。」

8、大量の UI 要素を表示する場合、どのように最適化しますか？
「オブジェクトプーリングで必要な分だけ再利用したり、表示領域外の要素を非アクティブにしてパフォーマンスを保つ。」

9、動的に UI を生成・破棄する処理を実装した経験はありますか？
「はい、プレハブ化した UI を インスタンス化して生成し、不要になったらプーリングや Destroy で管理しました。動的 UI はメモリ管理を意識して実装しました。」

10、UGUI のバッチング
「UGUI のバッチングは主に 同じマテリアル・同じテクスチャ・同じ Canvas 内・描画順が隣接 という条件で行われます。中間に異なるマテリアルやマスクが入るとバッチが分断されて draw call が増えます。ですから UI 最適化のためには、SpriteAtlas を利用して同じテクスチャをまとめ、不要な Canvas 分割やマスクの多用を避けることが大事です。」
11、UGUI の DrawCall を減らす方法

テクスチャアトラス（Sprite Atlas）の使用：
画像をまとめて同じテクスチャを参照することでバッチ化が保たれます。

Canvas の分割と更新頻度の制御：
Canvas ごとにバッチが分かれるため、Canvas の数を必要以上に増やさない。
動的 UI（頻繁に変わる部分）と静的 UI（めったに変わらない部分）を分けて配置。

同じマテリアル・描画順序の維持：
同じマテリアルを使用することでバッチ化が継続します。
異なるマテリアルやシェーダーを間に挟むと DrawCall が増えるので注意。

バッチを壊す要素の回避：
Mask、RectMask2D、半透明シェーダーなどはバッチを分断するため最小限にする。

計測・検証：
Frame Debugger や Profiler を使い、どのオブジェクトがバッチを壊しているのか確認することが重要です。

「UGUI の DrawCall 最適化のポイントは、SpriteAtlas を利用して同じテクスチャを共有すること、Canvas を適切に分けて更新コストを減らすこと、そして Mask や異なるマテリアルの使用を最小限にすることです。最後に、Frame Debugger で実際にどこでバッチが切れているかを確認するのが実務では欠かせません。」

12、

1、UGUI的合批规则
假设Canvas下有四个Image、分别为u1、u2、u3、u4。
Unity首先会判断这四个物体的深度值、如果当前为隐藏状态的话，深度值为-1，然后按照在Canvas下的顺序进行深度值判断，
如果有物体的Mesh覆盖在一个物体的Mesh上的话，那么该物体的深度值会比被覆盖物体大一，然后会检测Canvas下的顺序相邻的物体的MaterialId和TextureId是否相同，如果相同他们的深度值会设置为同一个值。最后得到一个待绘制合批的数组，如果深度值为-1的话不会被放进这个数组里，
按照深度值来进行一个Mesh一个Mesh的绘制，如果u1和u3的MaterialId和TextureId相同，但是u2与他们不相同的话，u2就会打断u1和u3的合批。

カンバスにはu1,u2,u3,u4四つのイメージがあると仮定します。Unityはこの四つのイメージの深度値を評価します、非表示の場合、深度値はー１となります、そしてカンバス内の順序(junjo[1])によって深度値を評価します。
もし一つのメッシュが別のメッシュを覆い隠して場合、その深度値は覆い隠されたの深度値より１大きい、
そしてカンバス内の隣接するイメージのマテリアルIDとテクスチャIDは同じかどうかを確認します、同じであれば深度値は同じ値に設定されます。最終的に、描画対象の配列が得られます、深度値はー１では、配列に含まれません。
深度値によって一つずつのメッシュを描画する。もしu1とu3のmatIDとTexIDが同じ場所、しかしu2は異なる場所、
u2はu1とu３のバッチングを妨げます。
2、如何减少UGUI产生的DrawCall
减少可能会引起脏标记的操作，也就是尽量减少UI元素变化。
使用相同的Material，使用图集使得TextureID相同。注意Canvas下的子物体排序顺序，不要被中间的物体打断相邻物体的合批。
不使用SetActive进行隐藏，而使用改变坐标进行隐藏。动静分离、ui元素容易变化的放在一个Canvas下，不变化的放在另一个Canvas下。
减少Mask的使用，只是矩形遮罩的话使用RectMask2D。

ダティーマークを引き起こすの可能性あるの操作を減らします、可能な限りにUI要素の変化(henka)を減少します。
同じマテリアルを使用し、スプライトアトラスを使用してテクスチャIDが同じになる。カンバス内のオブジェクトの並び順を注意し、中間のオブジェクトが隣接するオブジェクトのバッチングを妨げ(samatage)ないようにします。
非表示にする際は、SetActiveを使用せずに座標を変更します。静的な要素と変更しやすいUI要素は異なるCanvasに配置し
マスクの使用を減らす、矩形(kukei)のマスクにはRectMask2Dを使用します。

减少Layout相关组件的使用，因为layout组件计算布局的方式很耗费性能，
.不要嵌套Layout组件使用。

レイアウトコンポーネントの使用を減らし、レイアウトコンポーネントはレイアウトの計算が非常に性能を消耗(shoumou)するから、
レイアウトコンポーネントのネスト使用を避けます。

尽量一个界面的元素打进一个图集、尽量打小图进去、大图单独不打图集就行。

1つの画面の要素をできるだけ1つのスプライトアトラスに組み込みます。小さな画像を含めるようにし、大きな画像は単独でスプライトアトラスに含めないでください。

3、循环列表
UGUI中的循环列表是一种用于高效处理大量元素列表的方法。通常，当列表中的元素多到无法全部显示在视图区域内时，通过将滚动出屏幕的一些元素隐藏，并在需要时重新利用这些元素来优化内存和性能，从而实现高效的处理。

ループスクロールリストは、大量の要素を持つリストを効率的に扱うための手法です。通常、表示領域に格納されないほど多くのアイテムがある場合、画面外にスクロールしていくつかのアイテムを非表示にしておき、必要に応じて表示領域内に再利用することで、メモリやパフォーマンスでの効率的に処理できます。




