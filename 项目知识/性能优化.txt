1、优化思想
性能优化首先要分析问题，定位问题，收集数据来证明问题，然后制定解决对策进行优化，不能简单地通过猜测，推断来做性能优化。
先优化IOS、再优化安卓，先共性性能优化，再进行兼容性方面的性能优化。

2、常用方法
隔离法：隔离可疑区域，逐步缩小问题范围。

对比法：观察相同情况下的前后差异。

3、借助性能分析工具，分析性能瓶颈点。

4、卡顿优化

降帧法：通过强制降低更新频率，减缓卡顿的时间。

摊帧法：在同一帧处理的逻辑分为若干份，分摊到若干帧去处理，从而缓解同一帧的处理时间，减缓卡顿现象。

限制数量法：当场景内创建某种物体（角色，特效等）的数量到底最大值时，便强制不再创建。

对象池：重用对象，取代单独地分配和释放对象。

IO优化：
因IO慢引起主线程等待，从而导致游戏卡顿的现象非常普遍，下面有一些常用的优化技法。

预加载：
将耗时的IO提前到某个时刻（游戏启动时，场景加载时，进入主界面时等）加载，比如有些角色资源大，可以在加载战斗场景时提前加载，以免战斗过程中卡顿。

异步加载：
将IO异步化，以避免卡主线程。此技法应用非常普遍了，不再累述。

压缩资源：
将本来零散的文件压缩成单个文件，或者对大文件利用一定算法（如哈夫曼编码）压缩，减少文件大小。这样也可以降低IO时间。当然，压缩资源也有副作用，需占用多一份内存，解压缩过程也要耗费额外的CPU。

多级缓存：

CPU有L1、L2、L3缓存，它们速度有差别；内存的存取速度远低于CPU缓存；硬盘存取速度又远低于内存；而网络更慢。

因而加载资源时，先尝试从内存缓存读取，再尝试从硬盘加载，最后再考虑从网络下载。


我们都知道CPU的频率是最高的，目前家用PC的主频可达3.2GHz甚至更高，CPU内有L1L3缓存，它们速度略有差别；内存的存取速度远低于CPU，一般是23GHz，约是CPU的1/10。硬盘存取速度又远低于内存，普遍是0.1Gb/s，远低于内存读取速度。而网络更慢，目前即便是光纤，也不过0.02Gb/s。通常我们能操控的是内存/磁盘和网络的数据，所以只要关注它们的速度，它们的速度关系大致如下图。

进度条：
将卡顿逻辑抽离出来，分成若干阶段（step），每完成一个step，给一帧时间刷新UI进度条。

5、UI优化：
图片纹理优化，选用合适的图片纹理压缩格式。
UI合批优化
使用图集
尽量防止网格重建和布局重建。
6、内存优化：
缓存法：将需要重复创建的对象缓存起来，销毁时将它放入缓存列表，再次创建时优先从缓存列表中读取。
缓存法可以降低内存的创建/删除频率，避免碎片化。常用于数量多且创建频繁的物体
控制GC：
GC的触发一般分为两种：
引擎触发。一般是时间间隔到了，或者内存占有量到了某个阈值，引擎便会触发GC。
用户调用。通常引擎也提供了API给游戏应用，以便逻辑层可以控制GC的时机。例如Unity的GC.Collect()接口可以触发GC操作。

但是触发GC需要遍历内存池/托管堆/各类缓存表，还可能引发内存碎片整理操作，所以它需要耗费一定的CPU性能，是引起掉帧和卡顿的罪魁祸首之一。那么，我们就需要在逻辑层采用一些方法，避免触发GC，或者减少触发GC的处理时间。常用的方法：
避免频繁创建/删除。这个好理解，频繁创建删除对象，会引起很多内存碎片和无用对象，增加触发GC的几率和时间。
帧更新内尽量避免临时对象和创建内存。
for/while等循环内避免避免临时对象和创建内存。
尽量避免申请大块内存。申请大块内存会导致内存暴涨，提升GC的几率。
避免内存泄漏。这个需要每个技术人员的职业技能和觉悟，也可以通过一些辅助工具检查内存泄漏，详见1.3。
主动调用GC。比如在进入战斗前后，切换场景前后，切换主要界面前后调用GC，可以一定程度上减少内存占用，避免掉帧/卡顿。

7、渲染优化：
合批
光照模型
遮挡剔除
贴图阴影
带宽优化。



パフォーマンス最適化の基本思想

パフォーマンス最適化では、まず問題を正確に分析・特定し、データを収集することが重要です。
憶測(okusoku)や勘に頼らず、実際の測定データに基づいて改善方針を立てることを意識します。

最適化の流れとしては、
共通部分の最適化
iOS 向け最適化
Android 向け最適化
の順で対応するのが一般的です。

🧩 主な分析・最適化手法

原因の切り分け：
問題が発生しているところを段階的に絞り込み、ボトルネックを特定します。

比較検証：
同条件での変更前後を比較し、挙動や性能差を確認します。

性能分析ツールの活用：
Profiler(プロファイラー) や Frame Debugger(フレームデバッガー) などを使って、CPU・GPU の負荷を可視化し、最適化の方向性を決めます。

⚙️ フレーム落ち（カクつき）対策

更新頻度の調整：
更新処理の間隔を伸ばし、CPU の負荷を軽減します。

処理の分散化：
重い処理を一度に実行せず、複数フレームに分けて少しずつ実行します。

オブジェクトプールの利用：
頻繁に生成・破棄されるオブジェクトを再利用し、GC の発生を抑えます。

💾 IO 最適化

プリロード（事前読み込み）：
大きなリソースを事前に読み込み、プレイ中のロード時間を短縮します。

非同期ロード（Async Load）：
メインスレッドをブロックしないよう、非同期処理で読み込みを行います。

リソースの圧縮・統合：
複数のファイルをまとめて圧縮し、IO 処理の回数を減らします。

多層キャッシュの活用：
メモリ → ストレージ → ネットワークの順でキャッシュを利用し、高速アクセスを実現します。

🖼 UI 最適化

画像・テクスチャ圧縮形式の最適化

バッチ化の維持：同じテクスチャ・マテリアルを共有して DrawCall を削減します。

不要なレイアウト再構築やメッシュ再生成の回避

Canvas ごとにバッチが分かれるため、むやみに分けないようににします。

動的UI更新の削減、頻繁な更新を避け、Rebuild 発生を抑えます。

🧠 メモリ最適化

キャッシュの再利用：
頻繁に使うオブジェクトをキャッシュ化し、メモリ断片化を防ぎます。

GC（ガーベジコレクション）の発生抑制(よくせい)：
不要なオブジェクト生成・削除を減らし、フレーム落ちを防ぎます。

一時オブジェクトの削減：
Update 内など毎フレーム呼ばれる処理で、一時的なオブジェクト生成を避けます。

大容量メモリ割り当ての制御：
メモリを多く消費するデータはロードタイミングを調整し、使用量を平準化します。

メモリリークの防止： 
イベント登録解除忘れや参照残りを防ぎ、安定したメモリ利用を維持します。
 

